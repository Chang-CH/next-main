# Front end interview

## CSS

### Box model

CSS box model is a box that wraps around every HTML element. It consists of: margins, borders, padding, and the actual content.

1. Content - The content of the box, where text and images appear
2. Padding - Clears an area around the content. The padding is transparent
3. Border - A border that goes around the padding and content
4. Margin - Clears an area outside the border. The margin is transparent

When setting the height and width of an element, you set the **CONTENT** dimensions.

### Selectors

Note that these selectors can be combined, e.g. `p.test#demo` will select `<p id="demo" class="test">`.

1. element selector: `p {color: red;}`, general element
2. id selector: `#demo {color: red;}`, selects elements with demo id
3. class selector: `.demo {color: red;}`, selects elements with the demo class
4. universal selector: `* {color: red;}`, selects all elements
5. pseudo class selector: `p:first-child {color: red;}`, selects the first child of all p elements
   1. `:active` - Selects the active link
   2. `:hover` - Selects on mouse over
   3. `:visited` - Selects all visited links
   4. `:first-child` - Selects the first child element
6. pseudo element selector: `p::first-line` selects the first line of all p elements
   1. `a::after` - Insert something after the content of each `<p>` element.
7. ` ` descendant selector, `p span` selects all span elements inside p elements (regardless of nesting)
8. `>` child selector, `p > span` selects all span elements where the parent is a p element (direct child)
9. `+` adjacent sibling selector, `p + span` selects all span elements that are placed immediately after p elements (`<p/><span/>`)
10. `~` general sibling selector, `p ~ span` selects all span elements that are placed after (not before) p elements (`<p/><span/><span/>`)

```css
a::after {
  content: "click me";
}
```

```HTML
<!-- Code -->
<a>hello</a>
```

```HTML
<!-- Output -->
<a>hello ::after</a>
<!-- equals <a> hello click me</a> -->
```

    2.  `::before` - Insert something before the content of each `<p>` element
    3.  `::first-letter` - Selects the first letter of each `<p>` element
    4.  `::first-line` - Selects the first line of each `<p>` element
    5.  `::selection` - Selects the portion of an element that is selected by a user
    6.  `::marker` - Selects form elements with placeholder text

**Examples**

1. `p i`, selects all `<i>` elements inside `<p>` elements
2. `p i:first-child {color: red;}`, selects the first child of all `<i>` elements inside `<p>` elements

### Specificity

When 2 selectors apply to the same element, the one with higher specificity wins.

```css
#demo {
  color: blue;
}
.test {
  color: green;
}
p {
  color: red;
}
```

In this case, `<p id="demo" class="test" style="color: pink;">` will be pink, since specificity order =
(**inline style** > **id** > **class, pseudo class, attribute selectors** > **tag, elements, pseudo elements**)

### Layouts

## JS

- closure: a way for functions to modify variables outside of their body `var x = 1; function a() {console.log(x)}`. similar to `(() => this).bind(this)`.
  Closures hold reference to constants outside scope, even if outer scope destroyed the constant is not GC due to referenced count.
  - binding is less performant since it has additional checks as per the bind spec.
- `arguments`: built in constant, array of arguments, can be used anywhere in a function.
- `Proxy`: intercepts operations on objects, e.g. `get`, `set`. Example:

```js
const target = {
  msg1: "A",
  msg2: "B",
};

const handler = {
  get: function (obj, prop) {
    if (prop === "msg1") {
      return "C";
    }
    return Reflect.get(...arguments);
  },
};

const proxy = new Proxy(target, handler);
console.log(proxy.msg1); // C
console.log(proxy.msg2); // B
```

### Event loop

- `setTimeout`, DOM, AJAX (Async Js And Xml) etc. are not in V8(JS) runtime, it is implemented in the browser API.
- callback queue: contains event messages: `onClick`, `onLoad` etc.
- browser rendering happens on the same call stack as code logic. blocking/slow code will cause browser rendering freezes

```js
console.log("1");
setTimeout(() => console.log("2"), 0);
console.log("3");
```

1. `1` is printed
2. `setTimeout` line is executed. js side, we just get the promise. browserAPI `setTimeout` executes.
3. timer runs out, callback is pushed into task queue.
4. Event loop ** waits until stack is empty** before pushing code onto stack
5. Stack is not empty due to line 3, `3` is printed.
6. Stack is empty, callback is pushed onto stack, executed. `2` is printed.

Due to the logic of the event loop, we get some phenomena:

- `setTimeout(cb, 0)`: 0 second timeouts, effectively just defers running cb until stack is clear.
- browser render can only happen when stack is clear, so slow code will cause browser to freeze.
- render has higher priority than callbacks, so if stack is empty render gets pushed onto stack before callback queue.
- processing large array sync, browser cannot render in between. `setTimeout(cb, 0)` for each element, render happens in between processing each element.

### JQuery

Shorthand for DOM manipulation. e.g. `$("p").hide()` hides all `<p>` elements. Follows css selector syntax (including ` ` descendant, `>`, `~` etc.)

- effects: `$("#demo").fadeIn()`, `$("#demo").hide()` etc.
- traversing: `$("#demo").parent()`, `$("#demo").children()` etc.
- DOM manipulation: `$("#demo").append("<p>hello</p>")`, `$("#demo").attr("href", "a.com")` etc.

### Variable issues: immediately Invoked Function Expression (IIFE) + Scoping

before ES2015 JS only had var, and var did not have block scope, only function scope (anywhere in the function where they were declared).
So to create a scope, we use IIFE.

```js
{
  let p = 110;
  var q = 111;
}
console.log(p); // reference error
console.log(q); // ok

(function () {
  var q = 111;
})(); // notice the brackets around the function, if not will not work.
console.log(q); // reference error

var a = 1;
let b = 1;
{
  var a = 2;
  let b = 2;
}
// a = 2, b = 1
```

This is because of var **hoisting**: a variable is hoisted (regardless of block scope) to the top of the function it is declared in.
This is why `console.log(x); var x = 10;` works (it prints undefined)

### Prototypal Inheritance

```js
function Parent() {
  this.name = "Parent";
}

Parent.prototype.greet = function () {
  console.log("Hello from " + this.name);
};

const child = Object.create(Parent.prototype);

child.cry = () => console.log("AAA");
child.cry(); // AAA
child.greet(); // Hello from parent
```

## React

### Document Object Model (DOM)

The DOM is a interface for HTML documents. It is not specific to JS.
It represents all objects in the page as `Node`s. Different `Node` have different `Element` type, e.g. table, form etc.
Elements can further implement other HTML interfaces, e.g. `HTMLElement`, `HTMLTableElement`, etc.
HTML elements can be manipulated through the DOM by editing the properties of the interface they implement.
Notable objects:

1. `window`, `window.onload` etc.
2. `document`, `document.getElementById()` etc.
3. `Element.innerHTML`, `HTMLElement.style` etc.

### Virtual DOM

[link](https://blog.logrocket.com/virtual-dom-react/)

Implementing react FC in raw JS, it might look like `() => <div><button/><button/></div>`. Now if we rerender the first button due to state change,
the second button will get rerendered also. Virtual DOM tackles this by determining what has changed and only updates the parts of the DOM that changed.

1. Initial Virtual DOM: React creates a replica of the actual DOM tree, from the root element all the way down.
2. Diffing (Reconciliation): say state changed. React does DFS to traverse the virtual DOM and compare it with the snapshot of the previous virtual DOM.
   It then creates a list of differences. Differences do not just mean dirty flag, i.e. if parent component classname changes the diff is only the classname,
   children is not automatically assumed to be diffed (it will check the child also).
3. Render: React used ReactDOM to update the actual DOM.

This has some problems:

1. Large DOM: very big blog with a clock at the top. Every second the clock updates, so every second React diffs the entire huge blog DOM tree.
   1. [No library]: make the clock a separate component, so only the clock is diffed with itself.
   2. [million js]: Block Virtual DOM, million does static analysis to identify dynamic parts, create an edit map. Only diff the dynamic parts.
2. Shared state: 2 deeply nested child components need to share the same state
   1. [No library]: prop drilling, pass the state down to the children, `useEffect` listen to prop change. Causes rerenders at every level.
   2. [No library]: context, create a provider at the top, `useContext` at the bottom. Causes rerenders of all children of context provider also.
      can `useMemo` static components to avoid this.
   3. [Redux]: single giant state store. actually uses context under the hood but is opimized so only updated components rerender (the context never changes).
   4. [recoil]: atoms and selectors. atoms = state, selectors listen to the atoms/other selectors, when upstream update selector updates
