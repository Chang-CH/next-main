# Front end interview

## CSS

### Box model

CSS box model is a box that wraps around every HTML element. It consists of: margins, borders, padding, and the actual content.

1. Content - The content of the box, where text and images appear
2. Padding - Clears an area around the content. The padding is transparent
3. Border - A border that goes around the padding and content
4. Margin - Clears an area outside the border. The margin is transparent

When setting the height and width of an element, you set the **CONTENT** dimensions.

### Selectors

Note that these selectors can be combined, e.g. `p.test#demo` will select `<p id="demo" class="test">`.

1. element selector: `p {color: red;}`, general element
2. id selector: `#demo {color: red;}`, selects elements with demo id
3. class selector: `.demo {color: red;}`, selects elements with the demo class
4. universal selector: `* {color: red;}`, selects all elements
5. pseudo class selector: `p:first-child {color: red;}`, selects the first child of all p elements
   1. `:active` - Selects the active link
   2. `:hover` - Selects on mouse over
   3. `:visited` - Selects all visited links
   4. `:first-child` - Selects the first child element
6. pseudo element selector: `p::first-line` selects the first line of all p elements
   1. `a::after` - Insert something after the content of each `<p>` element.
7. ` ` descendant selector, `p span` selects all span elements inside p elements (regardless of nesting)
8. `>` child selector, `p > span` selects all span elements where the parent is a p element (direct child)
9. `+` adjacent sibling selector, `p + span` selects all span elements that are placed immediately after p elements (`<p/><span/>`)
10. `~` general sibling selector, `p ~ span` selects all span elements that are placed after (not before) p elements (`<p/><span/><span/>`)

```css
a::after {
  content: "click me";
}
```

```HTML
<!-- Code -->
<a>hello</a>
```

```HTML
<!-- Output -->
<a>hello ::after</a>
<!-- equals <a> hello click me</a> -->
```

    2.  `::before` - Insert something before the content of each `<p>` element
    3.  `::first-letter` - Selects the first letter of each `<p>` element
    4.  `::first-line` - Selects the first line of each `<p>` element
    5.  `::selection` - Selects the portion of an element that is selected by a user
    6.  `::marker` - Selects form elements with placeholder text

**Examples**

1. `p i`, selects all `<i>` elements inside `<p>` elements
2. `p i:first-child {color: red;}`, selects the first child of all `<i>` elements inside `<p>` elements

### Specificity

When 2 selectors apply to the same element, the one with higher specificity wins.

```css
#demo {
  color: blue;
}
.test {
  color: green;
}
p {
  color: red;
}
```

In this case, `<p id="demo" class="test" style="color: pink;">` will be pink, since specificity order =
(**inline style** > **id** > **class, pseudo class, attribute selectors** > **tag, elements, pseudo elements**)

### Layouts

## JS

Random stuff:

- `Proxy`: intercepts operations on objects, e.g. `get`, `set`. Example:

```js
const target = {
  msg1: "A",
  msg2: "B",
};

const handler = {
  get: function (obj, prop) {
    if (prop === "msg1") {
      return "C";
    }
    return Reflect.get(...arguments);
  },
};

const proxy = new Proxy(target, handler);
console.log(proxy.msg1); // C
console.log(proxy.msg2); // B
```

### This

Refers to the caller of a function, determined at **runtime**. Missing in arrow functions.
Can be bound ahead of time so `this` is fixed regardless of how its called.
Its value depends on the context in which it is called:

1. Function + object: `this` refers to the **object used** to call the function

```js
function get() {
  return this;
}
obj.func = get;
obj2.func = obj.func;
obj.func(); // obj
obj2.func(); // obj2
```

2. Function: If called directly `get()`, `this` is `undefined` in strict mode, `globalThis` in non strict
3. Callbacks: usually called directly `get()`, undefined.
4. Arrow functions: `this` is bound by closure to its context at creation (global scope, `globalThis`).
5. `super`: special case, `this` refers to the current object, not the parent `suepr` is pointing to.
6. constructor: `this` refers to the object returned by `new`.
7. derived constructor:`new Derived()`, `this` = `new Parent()`. constructor must return an object (overrides `this`), or call `super()` first.

### Var and Hoisting

variables (and functions) are either function scoped or global scoped. They are **NOT** block scoped.
Before any code runs, all variable and function declarations are hoisted to the top. Note that the initialization is not hoisted.

```js
console.log(a); // undefined
if (true) {
  var a = 1;
}
console.log(a); // 1, ignores block scope
function b() {
  var b = 2;
}
console.log(b); // ReferenceError, function scoped.
```

### Closures

- closure: a way for functions to access/modify variables outside of their body `const x = 1; function a() {console.log(x)}`. similar to `(() => this).bind(this)`.
- Created at function creation time.
- Closures hold reference to constants outside scope, even if outer scope destroyed the constant is not GC due to referenced count.
  - binding is less performant since it has additional checks as per the bind spec.
  - Can be used to make private variables: variable in outer scope can only be accessed in the function with closure.

```js
function a() {
  // also possible with if blocks and const/let
  const x = 1;
  return function b() {
    console.log(x);
  };
}
a()(); // 1
```

### arrow vs function declaration

Stuff missing in arrows:

- `arguments`: built in constant, array of arguments, can be used anywhere in a function.
- `this`: constant, reference to object that called the function. if arrow function is declared in a class, `this` is bound via closure.

Due to arrows missing `this`, they are good candidates for callbacks which need the outer `this`, e.g. in `setTimeout`.
In addition:

- arrows cannot be used as constructors

```js
class C {
  a = 999;
  B() { return this.a;}
  C = () => this.a; // closure binds C's this
}
const {B, C} = new C();
C(); // 999, B() gives TypeError: this is undefined.

const obj = {
  a = 999;
  B() { return this.a;}
  C = () => this.a; // obj has no this for C to bind
}
B(); // 999, C() gives TypeError: this is undefined.
```

### Event loop

- `setTimeout`, DOM, AJAX (Async Js And Xml) etc. are not in V8(JS) runtime, it is implemented in the browser API.
- callback queue: contains event messages: `onClick`, `onLoad` etc.
- browser rendering happens on the same call stack as code logic. blocking/slow code will cause browser rendering freezes

```js
console.log("1");
setTimeout(() => console.log("2"), 0);
console.log("3");
```

1. `1` is printed
2. `setTimeout` line is executed. js side, we just get the promise. browserAPI `setTimeout` executes.
3. timer runs out, callback is pushed into task queue.
4. Event loop ** waits until stack is empty** before pushing code onto stack
5. Stack is not empty due to line 3, `3` is printed.
6. Stack is empty, callback is pushed onto stack, executed. `2` is printed.

Due to the logic of the event loop, we get some phenomena:

- `setTimeout(cb, 0)`: 0 second timeouts, effectively just defers running cb until stack is clear.
- browser render can only happen when stack is clear, so slow code will cause browser to freeze.
- render has higher priority than callbacks, so if stack is empty render gets pushed onto stack before callback queue.
- processing large array sync, browser cannot render in between. `setTimeout(cb, 0)` for each element, render happens in between processing each element.

### JQuery

Shorthand for DOM manipulation. e.g. `$("p").hide()` hides all `<p>` elements. Follows css selector syntax (including ` ` descendant, `>`, `~` etc.)

- effects: `$("#demo").fadeIn()`, `$("#demo").hide()` etc.
- traversing: `$("#demo").parent()`, `$("#demo").children()` etc.
- DOM manipulation: `$("#demo").append("<p>hello</p>")`, `$("#demo").attr("href", "a.com")` etc.

### Variable issues: immediately Invoked Function Expression (IIFE) + Scoping

before ES2015 JS only had var, and var did not have block scope, only function scope (anywhere in the function where they were declared).
So to create a scope, we use IIFE.

```js
{
  let p = 110;
  var q = 111;
}
console.log(p); // reference error
console.log(q); // ok

(function () {
  var q = 111;
})(); // notice the brackets around the function, if not will not work.
console.log(q); // reference error

var a = 1;
let b = 1;
{
  var a = 2;
  let b = 2;
}
// a = 2, b = 1
```

This is because of var **hoisting**: a variable is hoisted (regardless of block scope) to the top of the function it is declared in.
This is why `console.log(x); var x = 10;` works (it prints undefined)

### Prototypal Inheritance

```js
function Parent(name) {
  this.name = name;
}

Parent.prototype.greet = function () {
  console.log("(P)Hello from " + this.name);
}; // const p = new Parent("name"); p.greet();

const child = Object.create(Parent.prototype);
// or child.prototype = Parent
child.name = "kid";
child.cry = () => console.log("AAA");
child.cry(); // AAA
child.greet(); // (P)Hello from kid
```

## React

### Document Object Model (DOM)

The DOM is a interface for HTML documents. It is not specific to JS.
It represents all objects in the page as `Node`s. Different `Node` have different `Element` type, e.g. table, form etc.
Elements can further implement other HTML interfaces, e.g. `HTMLElement`, `HTMLTableElement`, etc.
HTML elements can be manipulated through the DOM by editing the properties of the interface they implement.
Notable objects:

1. `window`, `window.onload` etc.
2. `document`, `document.getElementById()` etc.
3. `Element.innerHTML`, `HTMLElement.style` etc.

### Virtual DOM

[link](https://blog.logrocket.com/virtual-dom-react/)

Implementing react FC in raw JS, it might look like `() => <div><button/><button/></div>`. Now if we rerender the first button due to state change,
the second button will get rerendered also. Virtual DOM tackles this by determining what has changed and only updates the parts of the DOM that changed.

1. Initial Virtual DOM: React creates a replica of the actual DOM tree, from the root element all the way down.
2. Diffing (Reconciliation): say state changed. React does DFS to traverse the virtual DOM and compare it with the snapshot of the previous virtual DOM.
   It then creates a list of differences. Differences do not just mean dirty flag, i.e. if parent component classname changes the diff is only the classname,
   children is not automatically assumed to be diffed (it will check the child also).
3. Render: React used ReactDOM to update the actual DOM.

This has some problems:

1. Large DOM: very big blog with a clock at the top. Every second the clock updates, so every second React diffs the entire huge blog DOM tree.
   1. [No library]: make the clock a separate component, so only the clock is diffed with itself.
   2. [million js]: Block Virtual DOM, million does static analysis to identify dynamic parts, create an edit map. Only diff the dynamic parts.
2. Shared state: 2 deeply nested child components need to share the same state
   1. [No library]: prop drilling, pass the state down to the children, `useEffect` listen to prop change. Causes rerenders at every level.
   2. [No library]: context, create a provider at the top, `useContext` at the bottom. Causes rerenders of all children of context provider also.
      can `useMemo` static components to avoid this.
   3. [Redux]: single giant state store. actually uses context under the hood but is opimized so only updated components rerender (the context never changes).
   4. [recoil]: atoms and selectors. atoms = state, selectors listen to the atoms/other selectors, when upstream update selector updates
