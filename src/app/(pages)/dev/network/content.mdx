# Networking summary

## Visiting a page

### Resolving IP of page

1. Check local DNS cache (browser, OS)
2. Resolving nameserver (Internet Service Provider)
3. Root nameserver
4. Top Level Domain server (.com, .net etc.)
5. Authoritative DNS: DNS server of organization operating website, should have IP. (e.g. namecheap)

note: DNS resolution uses UDP. Use DNS over HTTPS to encrypt for privacy (default for firefox US).

### Initiate TCP connection

1. Client sends SYN packet to server
2. Server responds with SYN + ACK
3. Client sends ACK to server

### Establish HTTPS

[reference](https://www.cloudflare.com/learning/ssl/what-happens-in-a-tls-handshake/)

1. Client sends `Client hello` + cipher suites + client random + Diffie Hellman parameters
2. Server responds with `Server hello` + SSL Certificate (from CA authority) + server random + selected cipher suite + server random
   - server sends the `Finish` message, since it can calculate shared key already
3. Client calculate shared key from Diffie Hellman parameters + server random, send client `Finish`.

### Send HTTP request

1. send a GET request for the resources.
2. server responds with the resources.

### Misc trivia

- http port 80, https port 443
- `keep-alive` required to avoid having to `hello` each time a resource is requested (http, css, image).

## Internet layers

1. **Application**: `HTTP`, `SMTP`, actual data
2. **Transport**: process to process, (`TCP`/`UDP`)
3. **Network**: routing, source to dest. `IP`, routing protocols
4. **Link**: MAC address, home routers etc.
5. **Physical**: actual bits

## HTTP

### request components

- verb: `GET`, `POST`, `HEAD`(1.0), `PUT`, `DELETE`(1.1)

### response components

- response code (generated by server/gateway)
  1. `1XX` (information)
  2. `2XX` (success: `200 ok`, `201 created`, `202 accepted`)
  3. `3XX` (redirection: `301 moved permanently`)
  4. `4XX` (Client error)
  5. `5XX` (Server error)

Might be generated by gateway, e.g. amazon cloudfront, resource client trying to access returns 504 or cloudfront timeout, return 504.

## Transport protocols

### TCP

#### Features

- congestion control: throttle sender when network overloaded
- reliable: resend if no ACK
- Flow control: `rwnd` allows sender to control how much data receiver sends
- connection oriented: for each unique(src IP, src Port), server creates a new socket. client new socket for each port.
- No minimum throughput, no security

#### Datagram

<table>
  <tr>
    <td colSpan="16">src port</td>
    <td colSpan="16">dest port</td>
  </tr>
  <tr>
    <Details
      title="Sequence number"
      content="packet no, e.g. 1000 bytes Maximum Segment Size, seq no = (0, 1000, 2000, 3000...)"
    >
      <td colSpan="32">seq number</td>
    </Details>
  </tr>
  <tr>
    <Details title="ACK number" content="first byte of next packet expected">
      <td colSpan="32">ack number</td>
    </Details>
  </tr>
  <tr>
    <Details
      title="Header length"
      content="Number of 32 bit words in header. Minimum is 5 (no options)."
    >
      <td colSpan="4">header length</td>
    </Details>
    <td colSpan="6"></td>
    <Details
      title="Urgent flag"
      content="indicates urgent datagram. read data at urgent data ptr and send up first"
    >
      <td>Urgent</td>
    </Details>
    <Details
      title="ACK flag"
      content="indicates datagram contains ACK, needs to parse ACK"
    >
      <td>Ack</td>
    </Details>
    <Details title="Push flag" content="like urgent but push entire segment">
      <td>Push</td>
    </Details>
    <Details
      title="Reset flag"
      content="reset flag, indicates unable to parse, incorrect format etc."
    >
      <td>Reset</td>
    </Details>
    <Details title="Sync flag" content="Sync flag for signalling a handshake">
      <td>Syn</td>
    </Details>
    <Details
      title="Finish flag"
      content="Finish flag to signal connection close"
    >
      <td>Fin</td>
    </Details>
    <Details
      title="Receive window"
      content="indicates number of bytes receiver is willing to accept. Usually equals remaining free buffer."
    >
      <td colSpan="16">Receive Window</td>
    </Details>
  </tr>
  <tr>
    <Details
      title="Checksum"
      content="same as UDP: say data is 1000 1001 0001. 1001 + 1000 = 10001. wrap around, 0001 + 1 = 0010. 0010 + 0001 = 0011. checksum is 0011. "
    >
      <td colSpan="24">checksum</td>
    </Details>
    <Details
      title="Urgent Pointer"
      content="Used in conjunction with urgent flag, pointer to urgent data that needs to be passed up."
    >
      <td colSpan="8">urgent pointer</td>
    </Details>
  </tr>
  <tr>
    <Details>
      <td colSpan="32">options</td>
    </Details>
  </tr>
</table>

#### Process

1. Handshaking:
   1. client `LISTEN` send server `SYN`, seq = `x`. state change `SYN_SENT`
   2. server receive, state `LISTEN` to `SYN RCVD`. ACK with `SYN`, seq = `y`, ack = `x + 1`
   3. client receive, state `ESTAB`. ACK with `y + 1`. server state `ESTAB` on receive
2. closing TCP:
   1. client send server w/ `FIN` flag and seq = `x`, state becomes `FIN_WAIT_1`, cannot send anymore
   2. server ACK w/ `x + 1`, server state `CLOSE_WAIT`, server can still send. client receive, state becomes `FIN_WAIT_2`
   3. server does cleanup, send `FIN` flag segment w/ seq = `y`, server state `LAST_ACK`, cannot send. client state `TIMED_WAIT`
   4. client ACK `y + 1`, then wait 2x max segment lifetime before state `CLOSED`. server state `CLOSED` on receive ACK

#### TCP ACK generation

1. in order: delay 500ms, send ack
2. in order, pending ACK ^ not yet sent: immediate send ACK
3. out of order: immediate send dupe ACK
4. in order, out of order previously received: immediate ACK

- uses either Go Back N or Selective Repeat. buffer not in specification but usually both sender and recv have.
- ACK cumulative, ACK no = next packet expected

#### Timeout calculation

1. EstimatedRTT = (1 - x) _ EstimatedRTT + x _ SampleRTT`, `x`usually 1/8.`SampleRTT` = latest RTT
2. `DevRTT aka safety margin = (1-y) * DevRTT + y * |SampleRTT - EstimatedRTT|`, `y` usually 1/4. Deviation from mean
3. `Timeout = EstimatedRTT + 4 * DevRTT`

#### TCP fast retransmit

- If 4 un ACK'd segments received, resend even if not yet timeout

### UDP, User Datagram Protocol:

#### Datagram

<table>
  <tr>
    <td colSpan="16">src port</td>
    <td colSpan="16">dest port</td>
  </tr>
  <tr>
    <td colSpan="16">length</td>
    <td colSpan="16">checksum</td>
  </tr>
</table>

- Unreliable, does not have any features not in TCP
- Length includes header
- no handshake/setup. UDP has no idea if server received properly
- **Connectionless demultiplexing**: 1 socket for all client. sender attaches destination `IP` + `port`. Server use same port/socket for all.
- Checksum: detects errors. Keep summing 16 bit chunks of data. if MSB carry, wraparound to back. Invert sum to get checksum
- Used for DNS lookup.

## IPV4

Different Routers have different Max Transfer Units, MTU. If packet size > MTU, packet is fragmented. Fragmentation is done by router.

IPV4 Datagram Contents:

1. IP version
2. Header length
3. Identifier
4. Flags (Fragmentation Flag = 1 if fragmented, 0 = last fragment)
5. Fragment offset (Reassmble fragmented IP datagrams)
6. Time to live
7. Upper layer protocol (TCP, UDP)
8. Header checksum
9. Source CIDR IP
10. Destination CIDR IP

### Network Address Translation

Router has 1 public IP. All devices in LAN have private IP, WAN = public IP.

- Sending: Router changes (local) source IP to public IP. Store mapping of local IP/port to NAT IP/port.
- Receiving: use stored mapping, replace dest IP with local IP.

## Cross Origin Request Sharing

- HTTP header based mechanism, indicate any origins (domain, scheme, or port) other than its own from which a browser should permit loading resources.
- Include `Fetch`, images in canvas `drawImage` etc.
- some requests trigger a CORS preflight: `OPTION` request to server (with origin, method, headers), server return allowed, origin, methods etc.
- server can return `Access-Control-Allow-Origin: *` to allow all origins, or specific origins to guard against CSRF
- CSRF: attacker place form in _fake.com_, submit `POST` request to _bank.com_. If user is logged in, browser sends users session id also to _bank.com_. _bank.com_ thinks request is from user, and process request.
- Prevention: _bank.com_ can check `Origin` header, or use `SameSite` cookie.
